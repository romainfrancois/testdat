% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expect-generic.R
\name{generic-expectations}
\alias{generic-expectations}
\alias{expect_allany}
\alias{expect_all}
\alias{expect_any}
\alias{expect_where}
\title{Expectations: generic expectation helpers}
\usage{
expect_allany(
  vars,
  func,
  flt = TRUE,
  data = get_testdata(),
  args = list(),
  allany = c(chk_filter_all, chk_filter_any),
  func_desc = NULL
)

expect_all(...)

expect_any(...)

expect_where(
  where,
  func,
  flt = TRUE,
  data = get_testdata(),
  args = list(),
  func_desc = NULL
)
}
\arguments{
\item{vars}{a list of columns generated by \link[dplyr:vars]{vars()}}

\item{func}{a function that takes a vector as the first argument and returns
a logical vector of the same length showing whether an element passed or
failed}

\item{flt}{a filter specifying a subset of the dataset to test}

\item{data}{data frame to test. The \link[=global-data]{global test data} is used
by default.}

\item{args}{a named list of arguments to pass to \code{func}}

\item{allany}{function to use to combine results for each vector}

\item{func_desc}{A character function description to use in the expectation
failure message.}

\item{...}{arguments to pass to \code{expect_allany()}}

\item{where}{<\code{\link[=dplyr_tidy_select]{tidy-select}}> columns to check}
}
\description{
These functions allow for testing of a dataset using an arbitrary function.
Both \code{expect_all} and \code{expect_any} are wrappers around \code{expect_allany}. The
former, \code{expect_all}, tests the variables in \code{vars} to see whether \code{func}
returns TRUE for \emph{all} of them (i.e. whether the conjunction of results of
applying \code{func} to each of the \code{vars} is TRUE). The latter, \code{expect_any},
tests the \code{vars} to see whether \code{func} returns TRUE for \emph{any} of them (i.e.
whether the disjunction of the results of applying \code{func} to each of the \code{vars}
is TRUE). The \code{expect_where} function works exactly like \code{expect_all} except
that variables are specified not using \code{dplyr::vars()} (\code{vars}) but using
bare \code{\link[=dplyr_tidy_select]{tidy-select}} functions (\code{where}).
}
\examples{
\dontrun{
# Check that every 4-cylinder car has an engine displacement of < 100 cubic
# inches *AND* < 100 horsepower
expect_all(
  vars = vars(disp, hp),
  func = chk_range,
  flt = (cyl == 4),
  args = list(min = 0, max = 100),
  data = mtcars
)

# Check that every 4-cylinder car has an engine displacement of < 100 cubic
# inches *OR* < 100 horsepower
expect_any(
  vars = vars(disp, hp),
  func = chk_range,
  flt = (cyl == 4),
  args = list(min = 0, max = 100),
  data = mtcars
)
}

# Check petal dimensions are positive
expect_where(
  where = where(is.numeric),
  func = chk_range,
  args = list(min = 0, max = Inf),
  data = iris
)

}
\seealso{
\link{chk-generic} for a set of generic checking functions

Other data expectations: 
\code{\link{chk-expectations}},
\code{\link{conditional-expectations}},
\code{\link{datacomp-expectations}},
\code{\link{exclusivity-expectations}},
\code{\link{uniqueness-expectations}}
}
\concept{data expectations}
