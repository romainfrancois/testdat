#' @importFrom glue glue
NULL

#' Expectation params
#' @keywords internal
#' @param var an unquoted variable name
#' @param vars a list of columns generated by [vars()]
#' @param flt a filter specifying a subset of the dataset to test
#' @param miss a vector of values to be treated as missing. The
#'   [testdat.miss][testdat] option is used by default
#' @param data data frame to test. The [global test data][global-data] is used
#'   by default.
#' @export vars
#' @name data-params
NULL

#' Expectations: consistency checks
#'
#' These functions test whether multiple conditions coexist.
#'
#' `expect_cond` checks the coexistence of two conditions. It can be read as "if
#' `cond1` then `cond2`".
#'
#' `expect_base` is a special case that checks missing data against a specified
#' condition. It can be read as "if `base` then `var` not missing, if not `base`
#' then `var` missing".
#'
#' @inheritParams data-params
#' @family data expectations
#' @name conditional-expectations
NULL

#' @export
#' @rdname conditional-expectations
#' @param base condition for missing check
expect_base <- function(var, base, miss = getOption("testdat.miss"), data = get_testdata()) {
  # act <- list(val = get_testdata(), lab = "data")
  act <- quasi_label(enquo(data))

  act$var_desc <- expr_label(get_expr(enquo(var)))
  act$var <- expr_text(get_expr(enquo(var)))

  base <- enquo(base)
  act$base_desc <- expr_label(get_expr(base))
  act$base <- act$val %>% transmute(!!base) %>% pull(1)
  act$base[is.na(act$base)] <- FALSE

  act$miss <- (act$val[[act$var]] %in% miss) & act$base
  act$nmiss <- !(act$val[[act$var]] %in% miss) & !act$base
  act$result <- !(act$miss | act$nmiss)

  expect_custom(
    all(act$result, na.rm = TRUE),
    glue("{act$lab} has a base mismatch in variable {act$var_desc}.
          {sum(act$miss)} cases have {act$base_desc} but {act$var_desc} is missing.
          {sum(act$nmiss)} cases do not have {act$base_desc} but {act$var_desc} is non missing."),
    failed_count = sum(!act$result, na.rm = TRUE),
    total_count = sum(!is.na(act$result))
  )

  invisible(act$result)
}

#' @export
#' @rdname conditional-expectations
#' @param cond1 first condition for consistency check
#' @param cond2 second condition for consistency check
expect_cond <- function(cond1, cond2, data = get_testdata()) {
  # act <- list(val = get_testdata(), lab = "data")
  act <- quasi_label(enquo(data))

  cond1 <- enquo(cond1)
  act$cond1_desc <- expr_label(get_expr(cond1))
  act$cond1 <- act$val %>% transmute(!!cond1) %>% pull(1)
  act$cond1[is.na(act$cond1)] <- FALSE

  cond2 <- enquo(cond2)
  act$cond2_desc <- expr_label(get_expr(cond2))
  act$cond2 <- act$val %>% transmute(!!cond2) %>% pull(1)
  act$cond2[is.na(act$cond2)] <- FALSE

  act$result <- !(act$cond1 & !act$cond2)

  expect_custom(
    all(act$result, na.rm = TRUE),
    glue("{act$lab} failed consistency check. {sum(!act$result, na.rm = TRUE)} \\
          cases have {act$cond1_desc} but not {act$cond2_desc}."),
    failed_count = sum(!act$result, na.rm = TRUE),
    total_count = sum(!is.na(act$result))
  )

  invisible(act$result)
}

#' Expectations: value checks
#'
#' These functions test variable values
#'
#' @inheritParams data-params
#' @family data expectations
#' @name value-expectations
NULL

#' @export
#' @rdname value-expectations
#' @param ... vectors of valid values
expect_values <- function(var, ..., miss = getOption("testdat.miss"), data = get_testdata()) {
  # act <- list(val = get_testdata(), lab = "data")
  act <- quasi_label(enquo(data))

  act$var_desc <- expr_label(get_expr(enquo(var)))
  act$var <- expr_text(get_expr(enquo(var)))

  # act$vals_desc <- expr_label(get_expr(list(...))) %>% gsub("(^`list\\()|(\\)`$)", "`", .)
  act$vals_desc <- expr_text(get_expr(lapply(list(...), as.vector))) %>% gsub("(^list\\()|(\\)$)", "`", .)
  act$result <- act$val[[act$var]] %in% c(unlist(list(...)), miss)

  expect_custom(
    all(act$result, na.rm = TRUE),
    glue("{act$lab} has invalid values in variable {act$var_desc}. \\
          {sum(!act$result, na.rm = TRUE)} cases have values other than {act$vals_desc}."),
    data = list(table(act$val[[act$var]][!act$val[[act$var]] %in% unlist(list(...))])),
    failed_count = sum(!act$result, na.rm = TRUE),
    total_count = sum(!is.na(act$result))
  )

  invisible(act$result)
}

#' @export
#' @rdname value-expectations
#' @param pattern a regex to check
expect_regex <- function(var, pattern, flt = TRUE, data = get_testdata()) {
  expect_func(!!enquo(var), chk_pattern, !!enquo(flt), data, args = list(pattern))
}

# TODO
# #' @export
# #' @rdname value-expectations
expect_exclusive <- function(var, exc_var, data = get_testdata()) {
}

#' @export
#' @rdname value-expectations
expect_unique <- function(vars, flt = TRUE, data = get_testdata()) {
  act <- quasi_label(enquo(data))
  act$var_desc <- str_replace_all(expr_label(get_expr(enquo(vars))), "(^`vars\\(~?)|(\\)`$)", "`")
  act$flt_desc <- str_replace_all(expr_label(get_expr(enquo(flt))), "^TRUE$", "None")

  flt <- enquo(flt)
  act$result_data <- data %>%
    filter(!!flt) %>%
    group_by(!!!vars) %>%
    mutate(count = n()) %>%
    ungroup() %>%
    select(!!!vars, count)
    # select(!!!vars) %>%
    # duplicated %>%
    # `!`

  act$result <- act$result_data$count == 1

  expect_custom(
    all(act$result, na.rm = TRUE),
    glue("{act$lab} has {sum(!act$result, na.rm = TRUE)} duplicate records \\
         on variable {act$var_desc}.
         Filter: {act$flt_desc}"),
    failed_count = sum(!act$result, na.rm = TRUE),
    total_count = sum(!is.na(act$result)),
    duplicated_ids = act$result_data %>% filter(count > 1) %>% unique
  )

  invisible(act$result)
}

#' @export
#' @rdname value-expectations
expect_unique_across <- function(vars, flt = TRUE, data = get_testdata()) {
  act <- quasi_label(enquo(data))
  act$var_desc <- str_replace_all(expr_label(get_expr(enquo(vars))), "(^`vars\\(~?)|(\\)`$)", "`")
  act$flt_desc <- str_replace_all(expr_label(get_expr(enquo(flt))), "^TRUE$", "None")

  flt <- enquo(flt)
  act$result <- data %>%
    filter(!!flt) %>%
    select(!!!vars) %>%
    apply(1, function(x) { all(chk_unique(x)) })

  expect_custom(
    all(act$result, na.rm = TRUE),
    glue("{act$lab} has {sum(!act$result, na.rm = TRUE)} records with \\
         duplicates across variables {act$var_desc}.
         Filter: {act$flt_desc}"),
    failed_count = sum(!act$result, na.rm = TRUE),
    total_count = sum(!is.na(act$result))
  )

  invisible(act$result)
}

# TODO
# #' @export
# #' @rdname value-expectations
expect_unique_combine <- function(vars, flt = TRUE, data = get_testdata()) {
  browser()
  act <- quasi_label(enquo(data))
  act$var_desc <- str_replace_all(expr_label(get_expr(enquo(vars))), "(^`vars\\(~?)|(\\)`$)", "`")
  act$flt_desc <- str_replace_all(expr_label(get_expr(enquo(flt))), "^TRUE$", "None")

  flt <- enquo(flt)
  act$result <- data %>%
    filter(!!flt) %>%
    select(!!!vars) %>%
    gather(vars, val) %>%

  expect_custom(
    all(act$result, na.rm = TRUE),
    glue("{act$lab} has {sum(!act$result, na.rm = TRUE)} records with \\
         duplicates across variables {act$var_desc}.
         Filter: {act$flt_desc}"),
    failed_count = sum(!act$result, na.rm = TRUE),
    total_count = sum(!is.na(act$result))
    )

  invisible(act$result)
}

#' Expectations: generic expectations
#'
#' These functions allow for testing of a dataset using an arbitrary function.
#'
#' @inheritParams data-params
#' @param func a function that takes a vector as the first argument and returns
#'   a logical vector of the same length showing whether an element passed or
#'   failed
#' @param args a named list of arguments to pass to `func`
#' @seealso [check_generics] for a set of generic checking functions
#' @family data expectations
#' @name generic-expectations
NULL

expect_allany <- function(vars, func, flt = TRUE, data = get_testdata(), args = list(), allany) {
  act <- quasi_label(enquo(data))
  act$func_desc <- expr_label(get_expr(enquo(func)))
  act$var_desc  <- str_replace_all(expr_label(get_expr(enquo(vars))), "(^`vars\\(~?)|(\\)`$)", "`")
  act$flt_desc  <- str_replace_all(expr_label(get_expr(enquo(flt))), "^TRUE$", "None")
  act$args_desc <- str_replace_all(expr_label(get_expr(enquo(args))), "(^`list\\(~?)|(\\)`$)", "`")

  act$result <- allany(data, vars, func, !!enquo(flt), args)

  expect_custom(
    all(act$result, na.rm = TRUE),
    glue("{act$lab} has {sum(!act$result, na.rm = TRUE)} records failing \\
          {act$func_desc} on variable {act$var_desc}.
          Filter: {act$flt_desc}
          Arguments: {act$args_desc}"),
    failed_count = sum(!act$result, na.rm = TRUE),
    total_count = sum(!is.na(act$result))
  )

  invisible(act$result)
}

#' @export
#' @rdname generic-expectations
expect_all <- function(...) {
  expect_allany(..., allany = chk_filter_all)
}

#' @export
#' @rdname generic-expectations
expect_any <- function(...) {
  expect_allany(..., allany = chk_filter_any)
}

#' @export
#' @rdname generic-expectations
expect_func <- function(var, ...) {
  expect_allany(vars(!!enquo(var)), ..., allany = chk_filter_all)
}

#' Expectations: cross-dataset expectations
#'
#' These functions allow for dataset comparisons
#'
#' @inheritParams data-params
#' @param data2 the dataset to compare against
#' @family data expectations
#' @name datacomp-expectations
NULL

#' @export
#' @rdname datacomp-expectations
#' @param var2 an unquoted variable name from data2
#' @param flt2 a filter specifying a subset of data2 to test
#' @param threshold the maximum proportional difference allowed between the two
#'   categories
#' @param min the minimum number of responses for a category to allow
#'   comparison. This avoidmall categories raising spurious errors
expect_similar <- function(var, data2, var2, flt = TRUE, flt2 = flt,
                           threshold = 0.05, min = 100, data = get_testdata()) {
  act <- quasi_label(enquo(data))
  act$var_desc   <- str_replace_all(expr_label(get_expr(enquo(var))), "(^`vars\\(~?)|(\\)`$)", "`")
  act$data2_desc <- expr_label(get_expr(enquo(var)))
  act$var2_desc  <- str_replace_all(expr_label(get_expr(enquo(var))), "(^`vars\\(~?)|(\\)`$)", "`")
  act$flt_desc   <- str_replace_all(expr_label(get_expr(enquo(flt))), "^TRUE$", "None")
  act$flt2_desc  <- str_replace_all(expr_label(get_expr(enquo(flt))), "^TRUE$", "None")

  var <- enquo(var)
  var2 <- enquo(var2)
  data_tb  <- data  %>% group_by(!!var)  %>% summarise(freq = n())
  data2_tb <- data2 %>% group_by(!!var2) %>% summarise(freq = n())

  by_var <- structure(quo_text(var), names = quo_text(var2))
  act$result <-
    left_join(data_tb, data2_tb, by = by_var) %>%
    mutate(prop_diff = abs(freq.x - freq.y) / freq.x,
           pass = prop_diff < threshold | freq.x < min)

  expect_custom(
    all(act$result$pass, na.rm = TRUE),
    glue("{act$lab} has {sum(!act$result$pass, na.rm = TRUE)} \\
          values breaking the {threshold} similarity threshold for variable \\
          {act$var_desc}
          Values: {glue::collapse(act$result %>% filter(!pass) %>% pull(!!var), ', ')}
          Filter: {act$flt_desc}"),
    table = act$result
  )

  invisible(act$result$pass)
}

# TODO
# #' @export
# #' @rdname datacomp-expectations
expect_labels_identical <- function(data2, data = get_testdata()) {
  act <- quasi_label(enquo(data))
  act$data2_desc <- expr_label(get_expr(enquo(var)))

  act$result <- FALSE

  expect_custom(
    all(act$result, na.rm = TRUE),
    glue(""),
    table = act$result
    )

  invisible(act$result)
}
